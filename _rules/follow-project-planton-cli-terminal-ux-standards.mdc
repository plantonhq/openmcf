---
description: Terminal UX standards for OpenMCF CLI - guiding users towards success
globs:
  - "cmd/**/*.go"
  - "internal/cli/**/*.go"
alwaysApply: true
---

# Rule: OpenMCF CLI Terminal UX Standards

## Core Ethos

**Never just show an error - guide the user towards success.**

The CLI is the primary interface for a world-class infrastructure platform. Every error message, every status update, every piece of output is an opportunity to reduce frustration and help users succeed. We don't just tell users what went wrong - we show them exactly how to fix it.

**Sky is the limit.** We always shoot higher. A mediocre error message that says "file not found" is unacceptable when we could show the file path, explain why it might be missing, and suggest the exact command to verify.

---

## Technology Stack

Use proven terminal UX libraries:

- **[charmbracelet/lipgloss](https://github.com/charmbracelet/lipgloss)** - Styled terminal output with colors, borders, and layouts
- **[charmbracelet/bubbletea](https://github.com/charmbracelet/bubbletea)** - Interactive terminal UIs (for prompts, selections)

All UI components live in `internal/cli/ui/` and use the established style system.

---

## The Structured Error Pattern

Every user-facing error MUST follow the three-layer pattern:

### 1. Error Type (internal/cli/manifest/ or domain package)

```go
// ClipboardNotStackInputError indicates clipboard content is valid YAML
// but not a stack input (missing 'target' field).
type ClipboardNotStackInputError struct {
    Raw []byte  // Include context for beautiful display
}

func (e *ClipboardNotStackInputError) Error() string {
    return "clipboard content is not a stack input (missing 'target' field)"
}
```

### 2. Beautiful UI Function (internal/cli/ui/)

```go
func ClipboardNotStackInput(content []byte) {
    sep := separator(infoIcon)
    
    // 1. Clear header with icon
    fmt.Println(sep)
    fmt.Printf("%s  %s\n", infoIcon.Render("‚ÑπÔ∏è"), infoTitle.Render("Not a Stack Input"))
    fmt.Println(sep)
    
    // 2. Explain what went wrong
    fmt.Println(infoMessage.Render("The clipboard content is valid YAML but not a stack input."))
    
    // 3. Show what was received (content preview)
    preview := formatContentPreview(content)
    fmt.Println(warningTitle.Render("Content preview:"))
    fmt.Println(preview)
    
    // 4. Show what was expected (correct format)
    fmt.Println(infoTitle.Render("Expected stack input format:"))
    fmt.Printf("    %s\n", Cmd("target:"))
    fmt.Printf("    %s\n", Cmd("  apiVersion: ..."))
    
    // 5. Actionable tip to resolve
    fmt.Printf("%s %s\n", infoIcon.Render(iconTip),
        infoMessage.Render("Tip: Use '--clip' without '-i' for raw manifests."))
    
    fmt.Println(sep)
}
```

### 3. Error Handler (detects type, displays UI)

```go
func HandleClipboardError(err error) bool {
    switch e := err.(type) {
    case *ClipboardNotStackInputError:
        ui.ClipboardNotStackInput(e.Raw)
        return true
    // ... other cases
    }
    return false
}
```

---

## UI Component Anatomy

Every error/info display MUST include:

| Component | Purpose | Required |
|-----------|---------|----------|
| **Separator Banner** | Visual boundary, draws attention | Yes |
| **Icon + Title** | Quick identification of message type | Yes |
| **Explanation** | What went wrong, in plain language | Yes |
| **Content Preview** | Show what was received (when applicable) | When relevant |
| **Expected Format** | Show what correct input looks like | When applicable |
| **Causes List** | Common reasons this error occurs | For errors |
| **Actionable Tip** | Specific command or action to resolve | Yes |
| **Suggested Command** | Copy-pasteable fix command | When possible |

---

## Color Palette & Icons

Use the established palette from `internal/cli/ui/styles.go`:

```go
// Semantic colors
colorRed     = "#FF6B6B"  // Errors
colorGreen   = "#69DB7C"  // Success
colorYellow  = "#FFD43B"  // Warnings, commands
colorBlue    = "#74C0FC"  // Info, paths
colorGray    = "#868E96"  // Dim/secondary text

// Icons
iconError   = "‚úó"
iconSuccess = "‚úì"
iconWarning = "!"
iconInfo    = "‚Üí"
iconTip     = "üí°"
```

---

## Reference Examples

Study these files for the established patterns:

| File | Demonstrates |
|------|--------------|
| `internal/cli/ui/clipboard.go` | Full error handling with preview, expected format, tips |
| `internal/cli/ui/manifest.go` | Error parsing, field suggestions, Levenshtein distance |
| `internal/cli/ui/messages.go` | Banner templates, styled output functions |
| `internal/cli/ui/styles.go` | lipgloss styles, color palette, icon constants |
| `internal/cli/manifest/clipboard_errors.go` | Structured error types with context |

---

## Anti-Patterns - FORBIDDEN

```go
// ‚ùå FORBIDDEN - Cryptic error dump
return errors.New("failed to parse manifest")

// ‚ùå FORBIDDEN - Raw error without guidance
fmt.Printf("Error: %v\n", err)

// ‚ùå FORBIDDEN - Technical jargon without explanation
return errors.Wrap(err, "proto unmarshal failed at offset 927")

// ‚ùå FORBIDDEN - Error without actionable next step
cliprint.PrintError("Invalid configuration")
```

---

## Required Patterns

```go
// ‚úÖ REQUIRED - Structured error with context
return &ClipboardNotStackInputError{Raw: content}

// ‚úÖ REQUIRED - Beautiful handler in command layer
if climanifest.HandleClipboardError(err) {
    os.Exit(1)  // Error already displayed beautifully
}

// ‚úÖ REQUIRED - UI function with full guidance
func ErrorWithGuidance(title string, causes []string, fix string, tip string)
```

---

## Quality Checklist

Before any CLI error handling is complete:

- [ ] Error has a structured type (not just `errors.New`)
- [ ] UI function shows clear title with appropriate icon
- [ ] Explanation is in plain language (no raw proto/json errors)
- [ ] Content preview shown when user input is involved
- [ ] Expected format shown when input format is wrong
- [ ] At least one actionable tip provided
- [ ] Suggested fix command provided when possible
- [ ] Uses lipgloss styles (not raw ANSI codes)
- [ ] Handler function wired up in command layer

---

## The Golden Rule

**If a user sees an error and has to ask "what do I do now?", we have failed.**

Every error message should answer:
1. What went wrong?
2. Why might this have happened?
3. What should I do to fix it?
4. What command should I run?
