// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file org/openmcf/provider/kubernetes/kubernetesdaemonset/v1/spec.proto (package org.openmcf.provider.kubernetes.kubernetesdaemonset.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_buf_validate_validate } from "../../../../../../buf/validate/validate_pb";
import type { Container, ContainerImage, ContainerResources } from "../../kubernetes_pb";
import { file_org_openmcf_provider_kubernetes_kubernetes } from "../../kubernetes_pb";
import type { KubernetesSensitiveValue } from "../../kubernetes_secret_pb";
import { file_org_openmcf_provider_kubernetes_kubernetes_secret } from "../../kubernetes_secret_pb";
import { file_org_openmcf_provider_kubernetes_options } from "../../options_pb";
import type { Probe } from "../../probe_pb";
import { file_org_openmcf_provider_kubernetes_probe } from "../../probe_pb";
import type { KubernetesClusterSelector } from "../../target_cluster_pb";
import { file_org_openmcf_provider_kubernetes_target_cluster } from "../../target_cluster_pb";
import type { VolumeMount } from "../../volume_mount_pb";
import { file_org_openmcf_provider_kubernetes_volume_mount } from "../../volume_mount_pb";
import type { StringValueOrRef } from "../../../../shared/foreignkey/v1/foreign_key_pb";
import { file_org_openmcf_shared_foreignkey_v1_foreign_key } from "../../../../shared/foreignkey/v1/foreign_key_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file org/openmcf/provider/kubernetes/kubernetesdaemonset/v1/spec.proto.
 */
export const file_org_openmcf_provider_kubernetes_kubernetesdaemonset_v1_spec: GenFile = /*@__PURE__*/
  fileDesc("CkFvcmcvb3Blbm1jZi9wcm92aWRlci9rdWJlcm5ldGVzL2t1YmVybmV0ZXNkYWVtb25zZXQvdjEvc3BlYy5wcm90bxI2b3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxIskIChdLdWJlcm5ldGVzRGFlbW9uU2V0U3BlYxJSCg50YXJnZXRfY2x1c3RlchgBIAEoCzI6Lm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMuS3ViZXJuZXRlc0NsdXN0ZXJTZWxlY3RvchJfCgluYW1lc3BhY2UYAiABKAsyMi5vcmcub3Blbm1jZi5zaGFyZWQuZm9yZWlnbmtleS52MS5TdHJpbmdWYWx1ZU9yUmVmQhi6SAPIAQGI1GHEBpLUYQlzcGVjLm5hbWUSGAoQY3JlYXRlX25hbWVzcGFjZRgDIAEoCBJvCgljb250YWluZXIYBCABKAsyVC5vcmcub3Blbm1jZi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldENvbnRhaW5lckIGukgDyAEBEngKDW5vZGVfc2VsZWN0b3IYBSADKAsyYS5vcmcub3Blbm1jZi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldFNwZWMuTm9kZVNlbGVjdG9yRW50cnkSagoLdG9sZXJhdGlvbnMYBiADKAsyVS5vcmcub3Blbm1jZi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldFRvbGVyYXRpb24ScgoPdXBkYXRlX3N0cmF0ZWd5GAcgASgLMlkub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRVcGRhdGVTdHJhdGVneRIZChFtaW5fcmVhZHlfc2Vjb25kcxgIIAEoBRIeChZjcmVhdGVfc2VydmljZV9hY2NvdW50GAkgASgIEhwKFHNlcnZpY2VfYWNjb3VudF9uYW1lGAogASgJEnQKC2NvbmZpZ19tYXBzGAsgAygLMl8ub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRTcGVjLkNvbmZpZ01hcHNFbnRyeRJdCgRyYmFjGAwgASgLMk8ub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRSYmFjGjMKEU5vZGVTZWxlY3RvckVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEaMQoPQ29uZmlnTWFwc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEiygEKHEt1YmVybmV0ZXNEYWVtb25TZXRDb250YWluZXISbAoDYXBwGAEgASgLMlcub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRDb250YWluZXJBcHBCBrpIA8gBARI8CghzaWRlY2FycxgCIAMoCzIqLm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMuQ29udGFpbmVyIvwHCh9LdWJlcm5ldGVzRGFlbW9uU2V0Q29udGFpbmVyQXBwEv4BCgVpbWFnZRgBIAEoCzIvLm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMuQ29udGFpbmVySW1hZ2VCvQG6SLkBugFaCh1zcGVjLmNvbnRhaW5lci5hcHAuaW1hZ2UucmVwbxIWSW1hZ2UgcmVwbyBpcyByZXF1aXJlZBohaGFzKHRoaXMucmVwbykgJiYgdGhpcy5yZXBvICE9ICcnugFWChxzcGVjLmNvbnRhaW5lci5hcHAuaW1hZ2UudGFnEhVJbWFnZSB0YWcgaXMgcmVxdWlyZWQaH2hhcyh0aGlzLnRhZykgJiYgdGhpcy50YWcgIT0gJyfIAQESaQoJcmVzb3VyY2VzGAIgASgLMjMub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5Db250YWluZXJSZXNvdXJjZXNCIbr7pAIcCgwKBTEwMDBtEgMxR2kSDAoDNTBtEgUxMDBNaRJnCgNlbnYYAyABKAsyWi5vcmcub3Blbm1jZi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldENvbnRhaW5lckFwcEVudhJqCgVwb3J0cxgEIAMoCzJbLm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RhZW1vbnNldC52MS5LdWJlcm5ldGVzRGFlbW9uU2V0Q29udGFpbmVyQXBwUG9ydBJDCg12b2x1bWVfbW91bnRzGAUgAygLMiwub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5Wb2x1bWVNb3VudBI+Cg5saXZlbmVzc19wcm9iZRgGIAEoCzImLm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMuUHJvYmUSPwoPcmVhZGluZXNzX3Byb2JlGAcgASgLMiYub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5Qcm9iZRI9Cg1zdGFydHVwX3Byb2JlGAggASgLMiYub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5Qcm9iZRIPCgdjb21tYW5kGAkgAygJEgwKBGFyZ3MYCiADKAkSdAoQc2VjdXJpdHlfY29udGV4dBgLIAEoCzJaLm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RhZW1vbnNldC52MS5LdWJlcm5ldGVzRGFlbW9uU2V0U2VjdXJpdHlDb250ZXh0Iu0DCiJLdWJlcm5ldGVzRGFlbW9uU2V0Q29udGFpbmVyQXBwRW52EnwKCXZhcmlhYmxlcxgBIAMoCzJpLm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RhZW1vbnNldC52MS5LdWJlcm5ldGVzRGFlbW9uU2V0Q29udGFpbmVyQXBwRW52LlZhcmlhYmxlc0VudHJ5EngKB3NlY3JldHMYAiADKAsyZy5vcmcub3Blbm1jZi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXNkYWVtb25zZXQudjEuS3ViZXJuZXRlc0RhZW1vblNldENvbnRhaW5lckFwcEVudi5TZWNyZXRzRW50cnkaZAoOVmFyaWFibGVzRW50cnkSCwoDa2V5GAEgASgJEkEKBXZhbHVlGAIgASgLMjIub3JnLm9wZW5tY2Yuc2hhcmVkLmZvcmVpZ25rZXkudjEuU3RyaW5nVmFsdWVPclJlZjoCOAEaaQoMU2VjcmV0c0VudHJ5EgsKA2tleRgBIAEoCRJICgV2YWx1ZRgCIAEoCzI5Lm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMuS3ViZXJuZXRlc1NlbnNpdGl2ZVZhbHVlOgI4ASKJBAojS3ViZXJuZXRlc0RhZW1vblNldENvbnRhaW5lckFwcFBvcnQS/AEKBG5hbWUYASABKAlC7QG6SOkBugHiAQodc3BlYy5jb250YWluZXIuYXBwLnBvcnRzLm5hbWUSkgFOYW1lIGZvciBwb3J0cyBtdXN0IG9ubHkgY29udGFpbiBsb3dlcmNhc2UgYWxwaGFudW1lcmljIGNoYXJhY3RlcnMgYW5kIGh5cGhlbnMuIFBvcnQgbmFtZXMgbXVzdCBhbHNvIHN0YXJ0IGFuZCBlbmQgd2l0aCBhbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVyLhosdGhpcy5tYXRjaGVzKCdeW2EtejAtOV1bYS16MC05LV0qW2EtejAtOV0kJynIAQESHgoOY29udGFpbmVyX3BvcnQYAiABKAVCBrpIA8gBARKvAQoQbmV0d29ya19wcm90b2NvbBgDIAEoCUKUAbpIkAG6AYkBCilzcGVjLmNvbnRhaW5lci5hcHAucG9ydHMubmV0d29ya19wcm90b2NvbBI8VGhlIG5ldHdvcmsgcHJvdG9jb2wgbXVzdCBiZSBvbmUgb2YgIlNDVFAiLCAiVENQIiwgb3IgIlVEUCIuGh50aGlzIGluIFsiU0NUUCIsICJUQ1AiLCAiVURQIl3IAQESEQoJaG9zdF9wb3J0GAQgASgFIrMDCh1LdWJlcm5ldGVzRGFlbW9uU2V0VG9sZXJhdGlvbhILCgNrZXkYASABKAkSkAEKCG9wZXJhdG9yGAIgASgJQn66SHu6AXgKGXNwZWMudG9sZXJhdGlvbnMub3BlcmF0b3ISMFRoZSBvcGVyYXRvciBtdXN0IGJlIG9uZSBvZiAiRXhpc3RzIiBvciAiRXF1YWwiLhopdGhpcyA9PSAiIiB8fCB0aGlzIGluIFsiRXhpc3RzIiwgIkVxdWFsIl0SDQoFdmFsdWUYAyABKAkSxgEKBmVmZmVjdBgEIAEoCUK1AbpIsQG6Aa0BChdzcGVjLnRvbGVyYXRpb25zLmVmZmVjdBJLVGhlIGVmZmVjdCBtdXN0IGJlIG9uZSBvZiAiTm9TY2hlZHVsZSIsICJQcmVmZXJOb1NjaGVkdWxlIiwgb3IgIk5vRXhlY3V0ZSIuGkV0aGlzID09ICIiIHx8IHRoaXMgaW4gWyJOb1NjaGVkdWxlIiwgIlByZWZlck5vU2NoZWR1bGUiLCAiTm9FeGVjdXRlIl0SGgoSdG9sZXJhdGlvbl9zZWNvbmRzGAUgASgDIscCCiFLdWJlcm5ldGVzRGFlbW9uU2V0VXBkYXRlU3RyYXRlZ3kSrwEKBHR5cGUYASABKAlCoAG6SJwBugGYAQoZc3BlYy51cGRhdGVfc3RyYXRlZ3kudHlwZRJGVGhlIHVwZGF0ZSBzdHJhdGVneSB0eXBlIG11c3QgYmUgb25lIG9mICJSb2xsaW5nVXBkYXRlIiBvciAiT25EZWxldGUiLhozdGhpcyA9PSAiIiB8fCB0aGlzIGluIFsiUm9sbGluZ1VwZGF0ZSIsICJPbkRlbGV0ZSJdEnAKDnJvbGxpbmdfdXBkYXRlGAIgASgLMlgub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRSb2xsaW5nVXBkYXRlIk4KIEt1YmVybmV0ZXNEYWVtb25TZXRSb2xsaW5nVXBkYXRlEhcKD21heF91bmF2YWlsYWJsZRgBIAEoCRIRCgltYXhfc3VyZ2UYAiABKAkijgIKIkt1YmVybmV0ZXNEYWVtb25TZXRTZWN1cml0eUNvbnRleHQSEgoKcHJpdmlsZWdlZBgBIAEoCBITCgtydW5fYXNfdXNlchgCIAEoAxIUCgxydW5fYXNfZ3JvdXAYAyABKAMSFwoPcnVuX2FzX25vbl9yb290GAQgASgIEiEKGXJlYWRfb25seV9yb290X2ZpbGVzeXN0ZW0YBSABKAgSbQoMY2FwYWJpbGl0aWVzGAYgASgLMlcub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRDYXBhYmlsaXRpZXMiPAofS3ViZXJuZXRlc0RhZW1vblNldENhcGFiaWxpdGllcxILCgNhZGQYASADKAkSDAoEZHJvcBgCIAMoCSLzAQoXS3ViZXJuZXRlc0RhZW1vblNldFJiYWMSagoNY2x1c3Rlcl9ydWxlcxgBIAMoCzJTLm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc2RhZW1vbnNldC52MS5LdWJlcm5ldGVzRGFlbW9uU2V0UmJhY1J1bGUSbAoPbmFtZXNwYWNlX3J1bGVzGAIgAygLMlMub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxLkt1YmVybmV0ZXNEYWVtb25TZXRSYmFjUnVsZSKJAQobS3ViZXJuZXRlc0RhZW1vblNldFJiYWNSdWxlEhwKCmFwaV9ncm91cHMYASADKAlCCLpIBZIBAggBEhsKCXJlc291cmNlcxgCIAMoCUIIukgFkgECCAESFwoFdmVyYnMYAyADKAlCCLpIBZIBAggBEhYKDnJlc291cmNlX25hbWVzGAQgAygJQrYDCjpjb20ub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzZGFlbW9uc2V0LnYxQglTcGVjUHJvdG9QAVpuZ2l0aHViLmNvbS9wbGFudG9uaHEvb3Blbm1jZi9hcGlzL29yZy9vcGVubWNmL3Byb3ZpZGVyL2t1YmVybmV0ZXMva3ViZXJuZXRlc2RhZW1vbnNldC92MTtrdWJlcm5ldGVzZGFlbW9uc2V0djGiAgVPT1BLS6oCNk9yZy5PcGVubWNmLlByb3ZpZGVyLkt1YmVybmV0ZXMuS3ViZXJuZXRlc2RhZW1vbnNldC5WMcoCNk9yZ1xPcGVubWNmXFByb3ZpZGVyXEt1YmVybmV0ZXNcS3ViZXJuZXRlc2RhZW1vbnNldFxWMeICQk9yZ1xPcGVubWNmXFByb3ZpZGVyXEt1YmVybmV0ZXNcS3ViZXJuZXRlc2RhZW1vbnNldFxWMVxHUEJNZXRhZGF0YeoCO09yZzo6T3Blbm1jZjo6UHJvdmlkZXI6Okt1YmVybmV0ZXM6Okt1YmVybmV0ZXNkYWVtb25zZXQ6OlYxYgZwcm90bzM", [file_buf_validate_validate, file_org_openmcf_provider_kubernetes_kubernetes, file_org_openmcf_provider_kubernetes_kubernetes_secret, file_org_openmcf_provider_kubernetes_options, file_org_openmcf_provider_kubernetes_probe, file_org_openmcf_provider_kubernetes_target_cluster, file_org_openmcf_provider_kubernetes_volume_mount, file_org_openmcf_shared_foreignkey_v1_foreign_key]);

/**
 * *
 * **KubernetesDaemonSetSpec** defines the configuration for deploying a DaemonSet on a Kubernetes cluster.
 * A DaemonSet ensures that all (or some) nodes run a copy of a pod. As nodes are added to the cluster,
 * pods are added to them. As nodes are removed from the cluster, those pods are garbage collected.
 * Common use cases include: cluster storage daemons, log collection daemons, and node monitoring daemons.
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec
 */
export type KubernetesDaemonSetSpec = Message<"org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec"> & {
  /**
   * Target Kubernetes Cluster
   *
   * @generated from field: org.openmcf.provider.kubernetes.KubernetesClusterSelector target_cluster = 1;
   */
  targetCluster?: KubernetesClusterSelector;

  /**
   * Kubernetes Namespace
   *
   * @generated from field: org.openmcf.shared.foreignkey.v1.StringValueOrRef namespace = 2;
   */
  namespace?: StringValueOrRef;

  /**
   * Flag to indicate if the namespace should be created
   *
   * @generated from field: bool create_namespace = 3;
   */
  createNamespace: boolean;

  /**
   * The container specifications for the DaemonSet.
   * This includes configurations for the main application container and any sidecar containers.
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer container = 4;
   */
  container?: KubernetesDaemonSetContainer;

  /**
   * Node selector for constraining the DaemonSet pods to run on specific nodes.
   * Key-value pairs that must match labels on nodes for the pod to be scheduled.
   *
   * @generated from field: map<string, string> node_selector = 5;
   */
  nodeSelector: { [key: string]: string };

  /**
   * Tolerations allow the DaemonSet pods to be scheduled on nodes with matching taints.
   * This is essential for running pods on master nodes or nodes with specific taints.
   *
   * @generated from field: repeated org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetToleration tolerations = 6;
   */
  tolerations: KubernetesDaemonSetToleration[];

  /**
   * The update strategy for the DaemonSet.
   * Controls how pods are updated when the DaemonSet specification changes.
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategy update_strategy = 7;
   */
  updateStrategy?: KubernetesDaemonSetUpdateStrategy;

  /**
   * Minimum number of seconds for which a newly created DaemonSet pod should be ready
   * without any of its container crashing, for it to be considered available.
   * Defaults to 0 (pod will be considered available as soon as it is ready).
   *
   * @generated from field: int32 min_ready_seconds = 8;
   */
  minReadySeconds: number;

  /**
   * *
   * Flag to indicate if a ServiceAccount should be created for this DaemonSet.
   * If true, a ServiceAccount with the name specified in service_account_name
   * (or the DaemonSet name if not specified) will be created.
   * The DaemonSet pods will use this ServiceAccount.
   *
   * @generated from field: bool create_service_account = 9;
   */
  createServiceAccount: boolean;

  /**
   * *
   * Name of the ServiceAccount to use for the DaemonSet pods.
   * If create_service_account is true, a ServiceAccount with this name will be created.
   * If create_service_account is false, this references an existing ServiceAccount.
   * If not specified and create_service_account is true, uses the DaemonSet name.
   *
   * @generated from field: string service_account_name = 10;
   */
  serviceAccountName: string;

  /**
   * *
   * ConfigMaps to create alongside the DaemonSet.
   * Key is the ConfigMap name, value is the content.
   * These ConfigMaps can be referenced in volume mounts.
   *
   * Example:
   *   config_maps:
   *     vector-config: |
   *       data_dir: /var/lib/vector
   *       sources:
   *         kubernetes_logs:
   *           type: kubernetes_logs
   *
   * @generated from field: map<string, string> config_maps = 11;
   */
  configMaps: { [key: string]: string };

  /**
   * *
   * RBAC configuration for the DaemonSet ServiceAccount.
   * Allows defining ClusterRole and Role permissions.
   * Only used if create_service_account is true.
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbac rbac = 12;
   */
  rbac?: KubernetesDaemonSetRbac;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSpec.
 * Use `create(KubernetesDaemonSetSpecSchema)` to create a new message.
 */
export const KubernetesDaemonSetSpecSchema: GenMessage<KubernetesDaemonSetSpec> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetesdaemonset_v1_spec, 0);

/**
 * *
 * **KubernetesDaemonSetContainer** specifies the container configuration for the DaemonSet.
 * It includes the main application container and any sidecar containers that need to run alongside it.
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer
 */
export type KubernetesDaemonSetContainer = Message<"org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer"> & {
  /**
   * The main application container specifications.
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp app = 1;
   */
  app?: KubernetesDaemonSetContainerApp;

  /**
   * A list of sidecar containers to be deployed alongside the main application container.
   *
   * @generated from field: repeated org.openmcf.provider.kubernetes.Container sidecars = 2;
   */
  sidecars: Container[];
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainer.
 * Use `create(KubernetesDaemonSetContainerSchema)` to create a new message.
 */
export const KubernetesDaemonSetContainerSchema: GenMessage<KubernetesDaemonSetContainer> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetesdaemonset_v1_spec, 1);

/**
 * *
 * **KubernetesDaemonSetContainerApp** specifies the configuration for the main application container.
 * It includes the container image, resource allocations, environment variables, and health probes.
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp
 */
export type KubernetesDaemonSetContainerApp = Message<"org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp"> & {
  /**
   * *
   * The container image to be used for the application.
   * The `pull_secret_name` is the name of the image pull secret to be configured in the Kubernetes DaemonSet resource.
   *
   * @generated from field: org.openmcf.provider.kubernetes.ContainerImage image = 1;
   */
  image?: ContainerImage;

  /**
   * The CPU and memory resources allocated to the application container.
   *
   * @generated from field: org.openmcf.provider.kubernetes.ContainerResources resources = 2;
   */
  resources?: ContainerResources;

  /**
   * *
   * The environment variables and secrets for the application container.
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv env = 3;
   */
  env?: KubernetesDaemonSetContainerAppEnv;

  /**
   * *
   * A list of ports to be configured for the application container.
   *
   * @generated from field: repeated org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppPort ports = 4;
   */
  ports: KubernetesDaemonSetContainerAppPort[];

  /**
   * *
   * Volume mounts for the container.
   * Supports ConfigMap, Secret, HostPath, EmptyDir, and PVC volumes.
   * DaemonSets commonly need HostPath mounts for log collection, node monitoring, etc.
   *
   * @generated from field: repeated org.openmcf.provider.kubernetes.VolumeMount volume_mounts = 5;
   */
  volumeMounts: VolumeMount[];

  /**
   * *
   * Liveness probe configuration.
   * Periodic probe of container liveness. Container will be restarted if the probe fails.
   *
   * @generated from field: org.openmcf.provider.kubernetes.Probe liveness_probe = 6;
   */
  livenessProbe?: Probe;

  /**
   * *
   * Readiness probe configuration.
   * Periodic probe of container service readiness.
   *
   * @generated from field: org.openmcf.provider.kubernetes.Probe readiness_probe = 7;
   */
  readinessProbe?: Probe;

  /**
   * *
   * Startup probe configuration.
   * Indicates whether the application within the container is started.
   *
   * @generated from field: org.openmcf.provider.kubernetes.Probe startup_probe = 8;
   */
  startupProbe?: Probe;

  /**
   * *
   * Command to run in the container (overrides the container image's ENTRYPOINT).
   *
   * @generated from field: repeated string command = 9;
   */
  command: string[];

  /**
   * *
   * Arguments to pass to the command (overrides the container image's CMD).
   *
   * @generated from field: repeated string args = 10;
   */
  args: string[];

  /**
   * *
   * Security context for the container.
   * DaemonSets often need privileged access for node-level operations.
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContext security_context = 11;
   */
  securityContext?: KubernetesDaemonSetSecurityContext;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerApp.
 * Use `create(KubernetesDaemonSetContainerAppSchema)` to create a new message.
 */
export const KubernetesDaemonSetContainerAppSchema: GenMessage<KubernetesDaemonSetContainerApp> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetesdaemonset_v1_spec, 2);

/**
 * *
 * **KubernetesDaemonSetContainerAppEnv** defines the environment variables and secrets for the application container.
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv
 */
export type KubernetesDaemonSetContainerAppEnv = Message<"org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv"> & {
  /**
   * *
   * A map of environment variable names to their values.
   * Each variable can be provided either as a literal string value or as a reference
   * to another OpenMCF resource's field.
   *
   * **Option 1: Direct string value**
   * ```yaml
   * variables:
   *   LOG_LEVEL:
   *     value: "info"
   * ```
   *
   * **Option 2: Reference to another resource's field**
   * ```yaml
   * variables:
   *   CLUSTER_NAME:
   *     valueFrom:
   *       kind: GcpGkeCluster
   *       name: my-cluster
   *       fieldPath: "status.outputs.name"
   * ```
   *
   * When using valueFrom references, the orchestrator resolves the reference
   * and populates the value field before invoking the IaC modules.
   *
   * @generated from field: map<string, org.openmcf.shared.foreignkey.v1.StringValueOrRef> variables = 1;
   */
  variables: { [key: string]: StringValueOrRef };

  /**
   * *
   * A map of secret environment variable names to their values.
   * Each secret can be provided either as a literal string value or as a reference
   * to an existing Kubernetes Secret.
   *
   * Using secret references is recommended for production deployments.
   *
   * @generated from field: map<string, org.openmcf.provider.kubernetes.KubernetesSensitiveValue> secrets = 2;
   */
  secrets: { [key: string]: KubernetesSensitiveValue };
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppEnv.
 * Use `create(KubernetesDaemonSetContainerAppEnvSchema)` to create a new message.
 */
export const KubernetesDaemonSetContainerAppEnvSchema: GenMessage<KubernetesDaemonSetContainerAppEnv> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetesdaemonset_v1_spec, 3);

/**
 * *
 * **KubernetesDaemonSetContainerAppPort** specifies the port configuration for the application container.
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppPort
 */
export type KubernetesDaemonSetContainerAppPort = Message<"org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppPort"> & {
  /**
   * The name of the port (e.g., "metrics", "health").
   * The name must only contain lowercase alphanumeric characters and hyphens.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The port number on the container.
   *
   * @generated from field: int32 container_port = 2;
   */
  containerPort: number;

  /**
   * The network protocol used by the port (e.g., "TCP", "UDP", "SCTP").
   *
   * @generated from field: string network_protocol = 3;
   */
  networkProtocol: string;

  /**
   * Host port to expose the container port on.
   * Use with caution as it limits where pods can be scheduled.
   *
   * @generated from field: int32 host_port = 4;
   */
  hostPort: number;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetContainerAppPort.
 * Use `create(KubernetesDaemonSetContainerAppPortSchema)` to create a new message.
 */
export const KubernetesDaemonSetContainerAppPortSchema: GenMessage<KubernetesDaemonSetContainerAppPort> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetesdaemonset_v1_spec, 4);

/**
 * *
 * **KubernetesDaemonSetToleration** defines a toleration for the DaemonSet pods.
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetToleration
 */
export type KubernetesDaemonSetToleration = Message<"org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetToleration"> & {
  /**
   * Key is the taint key that the toleration applies to.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * Operator represents a key's relationship to the value.
   * Valid operators are Exists and Equal. Defaults to Equal.
   *
   * @generated from field: string operator = 2;
   */
  operator: string;

  /**
   * Value is the taint value the toleration matches to.
   *
   * @generated from field: string value = 3;
   */
  value: string;

  /**
   * Effect indicates the taint effect to match.
   * Valid effects are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @generated from field: string effect = 4;
   */
  effect: string;

  /**
   * TolerationSeconds represents the period of time the toleration tolerates the taint.
   * Only applicable when effect is NoExecute.
   *
   * @generated from field: int64 toleration_seconds = 5;
   */
  tolerationSeconds: bigint;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetToleration.
 * Use `create(KubernetesDaemonSetTolerationSchema)` to create a new message.
 */
export const KubernetesDaemonSetTolerationSchema: GenMessage<KubernetesDaemonSetToleration> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetesdaemonset_v1_spec, 5);

/**
 * *
 * **KubernetesDaemonSetUpdateStrategy** defines the update strategy for the DaemonSet.
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategy
 */
export type KubernetesDaemonSetUpdateStrategy = Message<"org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategy"> & {
  /**
   * Type of update strategy.
   * Can be "RollingUpdate" or "OnDelete".
   * RollingUpdate: The DaemonSet controller creates new pods and deletes old ones progressively.
   * OnDelete: Pods are only updated when they are manually deleted.
   *
   * @generated from field: string type = 1;
   */
  type: string;

  /**
   * Rolling update config params. Present only if type = "RollingUpdate".
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRollingUpdate rolling_update = 2;
   */
  rollingUpdate?: KubernetesDaemonSetRollingUpdate;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetUpdateStrategy.
 * Use `create(KubernetesDaemonSetUpdateStrategySchema)` to create a new message.
 */
export const KubernetesDaemonSetUpdateStrategySchema: GenMessage<KubernetesDaemonSetUpdateStrategy> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetesdaemonset_v1_spec, 6);

/**
 * *
 * **KubernetesDaemonSetRollingUpdate** defines the parameters for rolling update strategy.
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRollingUpdate
 */
export type KubernetesDaemonSetRollingUpdate = Message<"org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRollingUpdate"> & {
  /**
   * The maximum number of DaemonSet pods that can be unavailable during the update.
   * Can be an absolute number or a percentage (e.g., "1" or "10%").
   * This cannot be 0 if maxSurge is 0.
   * Defaults to 1.
   *
   * @generated from field: string max_unavailable = 1;
   */
  maxUnavailable: string;

  /**
   * The maximum number of nodes with an existing available DaemonSet pod that can have
   * an updated DaemonSet pod during an update.
   * Can be an absolute number or a percentage (e.g., "1" or "10%").
   * Defaults to 0.
   *
   * @generated from field: string max_surge = 2;
   */
  maxSurge: string;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRollingUpdate.
 * Use `create(KubernetesDaemonSetRollingUpdateSchema)` to create a new message.
 */
export const KubernetesDaemonSetRollingUpdateSchema: GenMessage<KubernetesDaemonSetRollingUpdate> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetesdaemonset_v1_spec, 7);

/**
 * *
 * **KubernetesDaemonSetSecurityContext** defines the security context for the container.
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContext
 */
export type KubernetesDaemonSetSecurityContext = Message<"org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContext"> & {
  /**
   * Run as privileged container.
   * DaemonSets often need privileged access for node-level operations.
   *
   * @generated from field: bool privileged = 1;
   */
  privileged: boolean;

  /**
   * Run as a specific user ID.
   *
   * @generated from field: int64 run_as_user = 2;
   */
  runAsUser: bigint;

  /**
   * Run as a specific group ID.
   *
   * @generated from field: int64 run_as_group = 3;
   */
  runAsGroup: bigint;

  /**
   * Run as non-root user.
   *
   * @generated from field: bool run_as_non_root = 4;
   */
  runAsNonRoot: boolean;

  /**
   * Make the root filesystem read-only.
   *
   * @generated from field: bool read_only_root_filesystem = 5;
   */
  readOnlyRootFilesystem: boolean;

  /**
   * Capabilities to add or drop.
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetCapabilities capabilities = 6;
   */
  capabilities?: KubernetesDaemonSetCapabilities;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetSecurityContext.
 * Use `create(KubernetesDaemonSetSecurityContextSchema)` to create a new message.
 */
export const KubernetesDaemonSetSecurityContextSchema: GenMessage<KubernetesDaemonSetSecurityContext> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetesdaemonset_v1_spec, 8);

/**
 * *
 * **KubernetesDaemonSetCapabilities** defines Linux capabilities to add or drop.
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetCapabilities
 */
export type KubernetesDaemonSetCapabilities = Message<"org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetCapabilities"> & {
  /**
   * List of capabilities to add.
   *
   * @generated from field: repeated string add = 1;
   */
  add: string[];

  /**
   * List of capabilities to drop.
   *
   * @generated from field: repeated string drop = 2;
   */
  drop: string[];
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetCapabilities.
 * Use `create(KubernetesDaemonSetCapabilitiesSchema)` to create a new message.
 */
export const KubernetesDaemonSetCapabilitiesSchema: GenMessage<KubernetesDaemonSetCapabilities> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetesdaemonset_v1_spec, 9);

/**
 * *
 * KubernetesDaemonSetRbac defines RBAC permissions for the DaemonSet ServiceAccount.
 * Creates ClusterRole/ClusterRoleBinding for cluster-wide permissions
 * and Role/RoleBinding for namespace-scoped permissions.
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbac
 */
export type KubernetesDaemonSetRbac = Message<"org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbac"> & {
  /**
   * *
   * Cluster-wide RBAC rules.
   * Creates a ClusterRole and ClusterRoleBinding.
   * Use for permissions that span across namespaces (e.g., reading all pods).
   *
   * @generated from field: repeated org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacRule cluster_rules = 1;
   */
  clusterRules: KubernetesDaemonSetRbacRule[];

  /**
   * *
   * Namespace-scoped RBAC rules.
   * Creates a Role and RoleBinding in the DaemonSet's namespace.
   * Use for permissions limited to the deployment namespace.
   *
   * @generated from field: repeated org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacRule namespace_rules = 2;
   */
  namespaceRules: KubernetesDaemonSetRbacRule[];
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbac.
 * Use `create(KubernetesDaemonSetRbacSchema)` to create a new message.
 */
export const KubernetesDaemonSetRbacSchema: GenMessage<KubernetesDaemonSetRbac> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetesdaemonset_v1_spec, 10);

/**
 * *
 * KubernetesDaemonSetRbacRule defines a single RBAC policy rule.
 * Maps directly to Kubernetes RBAC PolicyRule.
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacRule
 */
export type KubernetesDaemonSetRbacRule = Message<"org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacRule"> & {
  /**
   * *
   * API groups containing the resources.
   * Use "" for core API group.
   * Example: [""], ["apps"], ["batch"]
   *
   * @generated from field: repeated string api_groups = 1;
   */
  apiGroups: string[];

  /**
   * *
   * Resources this rule applies to.
   * Example: ["pods", "services"], ["deployments"], ["configmaps", "secrets"]
   *
   * @generated from field: repeated string resources = 2;
   */
  resources: string[];

  /**
   * *
   * Verbs specifying the actions allowed.
   * Example: ["get", "list", "watch"], ["create", "update", "delete"]
   *
   * @generated from field: repeated string verbs = 3;
   */
  verbs: string[];

  /**
   * *
   * Resource names to limit the rule to specific resources.
   * If empty, the rule applies to all resources of the specified type.
   * Example: ["my-configmap", "my-secret"]
   *
   * @generated from field: repeated string resource_names = 4;
   */
  resourceNames: string[];
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetesdaemonset.v1.KubernetesDaemonSetRbacRule.
 * Use `create(KubernetesDaemonSetRbacRuleSchema)` to create a new message.
 */
export const KubernetesDaemonSetRbacRuleSchema: GenMessage<KubernetesDaemonSetRbacRule> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetesdaemonset_v1_spec, 11);

