// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file org/openmcf/provider/kubernetes/volume_mount.proto (package org.openmcf.provider.kubernetes, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_buf_validate_validate } from "../../../../buf/validate/validate_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file org/openmcf/provider/kubernetes/volume_mount.proto.
 */
export const file_org_openmcf_provider_kubernetes_volume_mount: GenFile = /*@__PURE__*/
  fileDesc("CjJvcmcvb3Blbm1jZi9wcm92aWRlci9rdWJlcm5ldGVzL3ZvbHVtZV9tb3VudC5wcm90bxIfb3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcyLIAwoLVm9sdW1lTW91bnQSFAoEbmFtZRgBIAEoCUIGukgDyAEBEhoKCm1vdW50X3BhdGgYAiABKAlCBrpIA8gBARIRCglyZWFkX29ubHkYAyABKAgSEAoIc3ViX3BhdGgYBCABKAkSSgoKY29uZmlnX21hcBgFIAEoCzI2Lm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMuQ29uZmlnTWFwVm9sdW1lU291cmNlEkMKBnNlY3JldBgGIAEoCzIzLm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMuU2VjcmV0Vm9sdW1lU291cmNlEkgKCWhvc3RfcGF0aBgHIAEoCzI1Lm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMuSG9zdFBhdGhWb2x1bWVTb3VyY2USSAoJZW1wdHlfZGlyGAggASgLMjUub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5FbXB0eURpclZvbHVtZVNvdXJjZRI9CgNwdmMYCSABKAsyMC5vcmcub3Blbm1jZi5wcm92aWRlci5rdWJlcm5ldGVzLlB2Y1ZvbHVtZVNvdXJjZSJeChVDb25maWdNYXBWb2x1bWVTb3VyY2USFAoEbmFtZRgBIAEoCUIGukgDyAEBEgsKA2tleRgCIAEoCRIMCgRwYXRoGAMgASgJEhQKDGRlZmF1bHRfbW9kZRgEIAEoBSJbChJTZWNyZXRWb2x1bWVTb3VyY2USFAoEbmFtZRgBIAEoCUIGukgDyAEBEgsKA2tleRgCIAEoCRIMCgRwYXRoGAMgASgJEhQKDGRlZmF1bHRfbW9kZRgEIAEoBSLTAgoUSG9zdFBhdGhWb2x1bWVTb3VyY2USFAoEcGF0aBgBIAEoCUIGukgDyAEBEqQCCgR0eXBlGAIgASgJQpUCukiRAroBjQIKDmhvc3RfcGF0aC50eXBlEnhUeXBlIG11c3QgYmUgb25lIG9mOiAiIiwgIkRpcmVjdG9yeU9yQ3JlYXRlIiwgIkRpcmVjdG9yeSIsICJGaWxlT3JDcmVhdGUiLCAiRmlsZSIsICJTb2NrZXQiLCAiQ2hhckRldmljZSIsICJCbG9ja0RldmljZSIagAFzaXplKHRoaXMpID09IDAgfHwgdGhpcyBpbiBbIiIsICJEaXJlY3RvcnlPckNyZWF0ZSIsICJEaXJlY3RvcnkiLCAiRmlsZU9yQ3JlYXRlIiwgIkZpbGUiLCAiU29ja2V0IiwgIkNoYXJEZXZpY2UiLCAiQmxvY2tEZXZpY2UiXSKlAQoURW1wdHlEaXJWb2x1bWVTb3VyY2USeQoGbWVkaXVtGAEgASgJQmm6SGa6AWMKEGVtcHR5X2Rpci5tZWRpdW0SJE1lZGl1bSBtdXN0IGJlIGVpdGhlciAiIiBvciAiTWVtb3J5Ihopc2l6ZSh0aGlzKSA9PSAwIHx8IHRoaXMgaW4gWyIiLCAiTWVtb3J5Il0SEgoKc2l6ZV9saW1pdBgCIAEoCSJACg9QdmNWb2x1bWVTb3VyY2USGgoKY2xhaW1fbmFtZRgBIAEoCUIGukgDyAEBEhEKCXJlYWRfb25seRgCIAEoCEKaAgojY29tLm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXNCEFZvbHVtZU1vdW50UHJvdG9QAVpBZ2l0aHViLmNvbS9wbGFudG9uaHEvb3Blbm1jZi9hcGlzL29yZy9vcGVubWNmL3Byb3ZpZGVyL2t1YmVybmV0ZXOiAgRPT1BLqgIfT3JnLk9wZW5tY2YuUHJvdmlkZXIuS3ViZXJuZXRlc8oCH09yZ1xPcGVubWNmXFByb3ZpZGVyXEt1YmVybmV0ZXPiAitPcmdcT3Blbm1jZlxQcm92aWRlclxLdWJlcm5ldGVzXEdQQk1ldGFkYXRh6gIiT3JnOjpPcGVubWNmOjpQcm92aWRlcjo6S3ViZXJuZXRlc2IGcHJvdG8z", [file_buf_validate_validate]);

/**
 * *
 * VolumeMount defines how to mount a volume into a container.
 * Supports multiple volume types: ConfigMap, Secret, HostPath, EmptyDir, and PVC.
 * Only one volume source should be specified per mount.
 *
 * Example usage:
 *   volumeMounts:
 *     - name: config
 *       mountPath: /etc/app/config.yaml
 *       configMap:
 *         name: app-config
 *         key: config.yaml
 *     - name: logs
 *       mountPath: /var/log
 *       hostPath:
 *         path: /var/log
 *         type: Directory
 *
 * @generated from message org.openmcf.provider.kubernetes.VolumeMount
 */
export type VolumeMount = Message<"org.openmcf.provider.kubernetes.VolumeMount"> & {
  /**
   * Name of the volume mount. Must be unique within the container.
   * Used to correlate with the volume definition.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Path within the container at which the volume should be mounted.
   * Must be an absolute path.
   *
   * @generated from field: string mount_path = 2;
   */
  mountPath: string;

  /**
   * Whether the volume should be mounted read-only.
   * Default is false.
   *
   * @generated from field: bool read_only = 3;
   */
  readOnly: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted.
   * Defaults to "" (volume's root).
   * Useful for mounting a subdirectory of a volume.
   *
   * @generated from field: string sub_path = 4;
   */
  subPath: string;

  /**
   * ConfigMap volume source.
   * Use this to mount a ConfigMap as a file or directory.
   *
   * @generated from field: org.openmcf.provider.kubernetes.ConfigMapVolumeSource config_map = 5;
   */
  configMap?: ConfigMapVolumeSource;

  /**
   * Secret volume source.
   * Use this to mount a Secret as a file or directory.
   *
   * @generated from field: org.openmcf.provider.kubernetes.SecretVolumeSource secret = 6;
   */
  secret?: SecretVolumeSource;

  /**
   * HostPath volume source.
   * Use this to mount a file or directory from the host node's filesystem.
   * Common for DaemonSets that need access to node-level resources.
   *
   * @generated from field: org.openmcf.provider.kubernetes.HostPathVolumeSource host_path = 7;
   */
  hostPath?: HostPathVolumeSource;

  /**
   * EmptyDir volume source.
   * Use this for temporary storage that is erased when the pod is removed.
   * Useful for scratch space, caching, or sharing data between containers.
   *
   * @generated from field: org.openmcf.provider.kubernetes.EmptyDirVolumeSource empty_dir = 8;
   */
  emptyDir?: EmptyDirVolumeSource;

  /**
   * PersistentVolumeClaim volume source.
   * Use this to mount an existing PVC.
   * For StatefulSets, this can reference a volumeClaimTemplate.
   *
   * @generated from field: org.openmcf.provider.kubernetes.PvcVolumeSource pvc = 9;
   */
  pvc?: PvcVolumeSource;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.VolumeMount.
 * Use `create(VolumeMountSchema)` to create a new message.
 */
export const VolumeMountSchema: GenMessage<VolumeMount> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_volume_mount, 0);

/**
 * *
 * ConfigMapVolumeSource mounts a ConfigMap as a volume.
 * The ConfigMap can be one defined in spec.config_maps or an existing ConfigMap in the namespace.
 *
 * When 'key' is specified, only that key is mounted as a single file.
 * When 'key' is not specified, all keys are mounted as files in the directory.
 *
 * Example - Mount entire ConfigMap as directory:
 *   configMap:
 *     name: app-config
 *
 * Example - Mount single key as file:
 *   configMap:
 *     name: app-config
 *     key: database.yaml
 *     path: db-config.yaml
 *
 * @generated from message org.openmcf.provider.kubernetes.ConfigMapVolumeSource
 */
export type ConfigMapVolumeSource = Message<"org.openmcf.provider.kubernetes.ConfigMapVolumeSource"> & {
  /**
   * Name of the ConfigMap to mount.
   * Can reference a ConfigMap defined in spec.config_maps or an existing one in the namespace.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Specific key from the ConfigMap to mount as a single file.
   * If not specified, all keys are mounted as files in the directory.
   *
   * @generated from field: string key = 2;
   */
  key: string;

  /**
   * If key is specified, this is the filename to use for the mounted file.
   * Defaults to the key name if not specified.
   * Example: key="config" path="app.yaml" mounts the "config" key as "app.yaml"
   *
   * @generated from field: string path = 3;
   */
  path: string;

  /**
   * Mode bits to use on created files. Must be a value between 0 and 0777.
   * Defaults to 0644.
   * Use 0755 (493 in decimal) for executable scripts.
   *
   * @generated from field: int32 default_mode = 4;
   */
  defaultMode: number;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.ConfigMapVolumeSource.
 * Use `create(ConfigMapVolumeSourceSchema)` to create a new message.
 */
export const ConfigMapVolumeSourceSchema: GenMessage<ConfigMapVolumeSource> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_volume_mount, 1);

/**
 * *
 * SecretVolumeSource mounts a Secret as a volume.
 * Works similarly to ConfigMapVolumeSource but for sensitive data.
 *
 * Example:
 *   secret:
 *     name: tls-certs
 *     key: tls.crt
 *     path: server.crt
 *
 * @generated from message org.openmcf.provider.kubernetes.SecretVolumeSource
 */
export type SecretVolumeSource = Message<"org.openmcf.provider.kubernetes.SecretVolumeSource"> & {
  /**
   * Name of the Secret to mount.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Specific key from the Secret to mount as a single file.
   * If not specified, all keys are mounted as files in the directory.
   *
   * @generated from field: string key = 2;
   */
  key: string;

  /**
   * If key is specified, this is the filename to use for the mounted file.
   * Defaults to the key name if not specified.
   *
   * @generated from field: string path = 3;
   */
  path: string;

  /**
   * Mode bits to use on created files. Must be a value between 0 and 0777.
   * Defaults to 0644.
   *
   * @generated from field: int32 default_mode = 4;
   */
  defaultMode: number;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.SecretVolumeSource.
 * Use `create(SecretVolumeSourceSchema)` to create a new message.
 */
export const SecretVolumeSourceSchema: GenMessage<SecretVolumeSource> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_volume_mount, 2);

/**
 * *
 * HostPathVolumeSource mounts a file or directory from the host node's filesystem.
 * Use with caution as it ties pods to specific nodes.
 *
 * Common use cases:
 * - Log collection DaemonSets mounting /var/log
 * - Node monitoring agents mounting /sys or /proc
 * - Container runtime sockets (e.g., /var/run/docker.sock)
 *
 * Example:
 *   hostPath:
 *     path: /var/log
 *     type: Directory
 *
 * @generated from message org.openmcf.provider.kubernetes.HostPathVolumeSource
 */
export type HostPathVolumeSource = Message<"org.openmcf.provider.kubernetes.HostPathVolumeSource"> & {
  /**
   * Path on the host to mount.
   *
   * @generated from field: string path = 1;
   */
  path: string;

  /**
   * Type of the host path.
   * Valid values:
   *   "" - Empty string (default) means no check is performed before mounting
   *   "DirectoryOrCreate" - Create directory if it doesn't exist
   *   "Directory" - Directory must exist
   *   "FileOrCreate" - Create file if it doesn't exist
   *   "File" - File must exist
   *   "Socket" - UNIX socket must exist
   *   "CharDevice" - Character device must exist
   *   "BlockDevice" - Block device must exist
   *
   * @generated from field: string type = 2;
   */
  type: string;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.HostPathVolumeSource.
 * Use `create(HostPathVolumeSourceSchema)` to create a new message.
 */
export const HostPathVolumeSourceSchema: GenMessage<HostPathVolumeSource> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_volume_mount, 3);

/**
 * *
 * EmptyDirVolumeSource creates an empty directory for temporary storage.
 * The directory is created when a pod is assigned to a node and exists as long as the pod runs.
 * Data is deleted when the pod is removed.
 *
 * Use cases:
 * - Scratch space for computations
 * - Checkpoint storage for crash recovery
 * - Shared space between containers in a pod
 *
 * Example - Default (disk-backed):
 *   emptyDir: {}
 *
 * Example - Memory-backed (faster, but uses RAM):
 *   emptyDir:
 *     medium: Memory
 *     sizeLimit: 256Mi
 *
 * @generated from message org.openmcf.provider.kubernetes.EmptyDirVolumeSource
 */
export type EmptyDirVolumeSource = Message<"org.openmcf.provider.kubernetes.EmptyDirVolumeSource"> & {
  /**
   * Medium for the empty directory.
   * "" (default) uses the node's default medium (typically disk).
   * "Memory" uses a tmpfs (RAM-backed filesystem).
   *
   * Memory-backed volumes are faster but:
   * - Count against container memory limits
   * - Are lost on node restart
   * - Should have sizeLimit set to prevent OOM
   *
   * @generated from field: string medium = 1;
   */
  medium: string;

  /**
   * Size limit for the empty directory.
   * Format: Kubernetes quantity (e.g., "1Gi", "500Mi").
   * Only strictly enforced when medium is "Memory".
   * For disk-backed volumes, this is a best-effort limit.
   *
   * @generated from field: string size_limit = 2;
   */
  sizeLimit: string;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.EmptyDirVolumeSource.
 * Use `create(EmptyDirVolumeSourceSchema)` to create a new message.
 */
export const EmptyDirVolumeSourceSchema: GenMessage<EmptyDirVolumeSource> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_volume_mount, 4);

/**
 * *
 * PvcVolumeSource mounts an existing PersistentVolumeClaim.
 *
 * For StatefulSets: The claimName can reference a volumeClaimTemplate name,
 * and the StatefulSet controller will automatically handle per-pod PVC binding.
 *
 * Example:
 *   pvc:
 *     claimName: data-volume
 *     readOnly: false
 *
 * @generated from message org.openmcf.provider.kubernetes.PvcVolumeSource
 */
export type PvcVolumeSource = Message<"org.openmcf.provider.kubernetes.PvcVolumeSource"> & {
  /**
   * Name of the PersistentVolumeClaim to mount.
   * For StatefulSets, this can be the name of a volumeClaimTemplate.
   *
   * @generated from field: string claim_name = 1;
   */
  claimName: string;

  /**
   * Whether the PVC should be mounted read-only.
   * Default is false.
   *
   * @generated from field: bool read_only = 2;
   */
  readOnly: boolean;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.PvcVolumeSource.
 * Use `create(PvcVolumeSourceSchema)` to create a new message.
 */
export const PvcVolumeSourceSchema: GenMessage<PvcVolumeSource> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_volume_mount, 5);

