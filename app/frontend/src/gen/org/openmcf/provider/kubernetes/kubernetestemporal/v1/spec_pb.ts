// @generated by protoc-gen-es v2.2.2 with parameter "target=ts"
// @generated from file org/openmcf/provider/kubernetes/kubernetestemporal/v1/spec.proto (package org.openmcf.provider.kubernetes.kubernetestemporal.v1, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_buf_validate_validate } from "../../../../../../buf/validate/validate_pb";
import type { ContainerResources } from "../../kubernetes_pb";
import { file_org_openmcf_provider_kubernetes_kubernetes } from "../../kubernetes_pb";
import type { KubernetesSensitiveValue } from "../../kubernetes_secret_pb";
import { file_org_openmcf_provider_kubernetes_kubernetes_secret } from "../../kubernetes_secret_pb";
import type { KubernetesClusterSelector } from "../../target_cluster_pb";
import { file_org_openmcf_provider_kubernetes_target_cluster } from "../../target_cluster_pb";
import type { StringValueOrRef } from "../../../../shared/foreignkey/v1/foreign_key_pb";
import { file_org_openmcf_shared_foreignkey_v1_foreign_key } from "../../../../shared/foreignkey/v1/foreign_key_pb";
import { file_org_openmcf_shared_options_options } from "../../../../shared/options/options_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file org/openmcf/provider/kubernetes/kubernetestemporal/v1/spec.proto.
 */
export const file_org_openmcf_provider_kubernetes_kubernetestemporal_v1_spec: GenFile = /*@__PURE__*/
  fileDesc("CkBvcmcvb3Blbm1jZi9wcm92aWRlci9rdWJlcm5ldGVzL2t1YmVybmV0ZXN0ZW1wb3JhbC92MS9zcGVjLnByb3RvEjVvcmcub3Blbm1jZi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXN0ZW1wb3JhbC52MSKHCAoWS3ViZXJuZXRlc1RlbXBvcmFsU3BlYxJSCg50YXJnZXRfY2x1c3RlchgBIAEoCzI6Lm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMuS3ViZXJuZXRlc0NsdXN0ZXJTZWxlY3RvchJfCgluYW1lc3BhY2UYAiABKAsyMi5vcmcub3Blbm1jZi5zaGFyZWQuZm9yZWlnbmtleS52MS5TdHJpbmdWYWx1ZU9yUmVmQhi6SAPIAQGI1GHEBpLUYQlzcGVjLm5hbWUSGAoQY3JlYXRlX25hbWVzcGFjZRgDIAEoCBJxCghkYXRhYmFzZRgEIAEoCzJXLm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc3RlbXBvcmFsLnYxLkt1YmVybmV0ZXNUZW1wb3JhbERhdGFiYXNlQ29uZmlnQga6SAPIAQESFgoOZGlzYWJsZV93ZWJfdWkYBSABKAgSJQodZW5hYmxlX2VtYmVkZGVkX2VsYXN0aWNzZWFyY2gYBiABKAgSHwoXZW5hYmxlX21vbml0b3Jpbmdfc3RhY2sYByABKAgSJgoSY2Fzc2FuZHJhX3JlcGxpY2FzGAggASgFQgWKph0BMUgAiAEBEmEKB2luZ3Jlc3MYCSABKAsyUC5vcmcub3Blbm1jZi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXN0ZW1wb3JhbC52MS5LdWJlcm5ldGVzVGVtcG9yYWxJbmdyZXNzEn4KFmV4dGVybmFsX2VsYXN0aWNzZWFyY2gYCiABKAsyXi5vcmcub3Blbm1jZi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXN0ZW1wb3JhbC52MS5LdWJlcm5ldGVzVGVtcG9yYWxFeHRlcm5hbEVsYXN0aWNzZWFyY2gSDwoHdmVyc2lvbhgLIAEoCRJuCg5keW5hbWljX2NvbmZpZxgMIAEoCzJWLm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc3RlbXBvcmFsLnYxLkt1YmVybmV0ZXNUZW1wb3JhbER5bmFtaWNDb25maWcSLAoSbnVtX2hpc3Rvcnlfc2hhcmRzGA0gASgFQgu6SAgaBhiAgAEoAUgBiAEBEmMKCHNlcnZpY2VzGA4gASgLMlEub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzdGVtcG9yYWwudjEuS3ViZXJuZXRlc1RlbXBvcmFsU2VydmljZXNCFQoTX2Nhc3NhbmRyYV9yZXBsaWNhc0IVChNfbnVtX2hpc3Rvcnlfc2hhcmRzIrUDCiBLdWJlcm5ldGVzVGVtcG9yYWxEYXRhYmFzZUNvbmZpZxJxCgdiYWNrZW5kGAEgASgOMlgub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzdGVtcG9yYWwudjEuS3ViZXJuZXRlc1RlbXBvcmFsRGF0YWJhc2VCYWNrZW5kQga6SAPIAQESdAoRZXh0ZXJuYWxfZGF0YWJhc2UYAiABKAsyWS5vcmcub3Blbm1jZi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXN0ZW1wb3JhbC52MS5LdWJlcm5ldGVzVGVtcG9yYWxFeHRlcm5hbERhdGFiYXNlEigKDWRhdGFiYXNlX25hbWUYBiABKAlCDIqmHQh0ZW1wb3JhbEgAiAEBEjUKD3Zpc2liaWxpdHlfbmFtZRgHIAEoCUIXiqYdE3RlbXBvcmFsX3Zpc2liaWxpdHlIAYgBARIhChlkaXNhYmxlX2F1dG9fc2NoZW1hX3NldHVwGAggASgIQhAKDl9kYXRhYmFzZV9uYW1lQhIKEF92aXNpYmlsaXR5X25hbWUinwEKIkt1YmVybmV0ZXNUZW1wb3JhbEV4dGVybmFsRGF0YWJhc2USDAoEaG9zdBgBIAEoCRIMCgRwb3J0GAIgASgFEhAKCHVzZXJuYW1lGAMgASgJEksKCHBhc3N3b3JkGAQgASgLMjkub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5LdWJlcm5ldGVzU2Vuc2l0aXZlVmFsdWUioAEKJ0t1YmVybmV0ZXNUZW1wb3JhbEV4dGVybmFsRWxhc3RpY3NlYXJjaBIMCgRob3N0GAEgASgJEgwKBHBvcnQYAiABKAUSDAoEdXNlchgDIAEoCRJLCghwYXNzd29yZBgEIAEoCzI5Lm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMuS3ViZXJuZXRlc1NlbnNpdGl2ZVZhbHVlIv4BChlLdWJlcm5ldGVzVGVtcG9yYWxJbmdyZXNzEnIKCGZyb250ZW5kGAEgASgLMmAub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzdGVtcG9yYWwudjEuS3ViZXJuZXRlc1RlbXBvcmFsRnJvbnRlbmRJbmdyZXNzRW5kcG9pbnQSbQoGd2ViX3VpGAIgASgLMl0ub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5rdWJlcm5ldGVzdGVtcG9yYWwudjEuS3ViZXJuZXRlc1RlbXBvcmFsV2ViVWlJbmdyZXNzRW5kcG9pbnQilgIKKUt1YmVybmV0ZXNUZW1wb3JhbEZyb250ZW5kSW5ncmVzc0VuZHBvaW50Eg8KB2VuYWJsZWQYASABKAgSFQoNZ3JwY19ob3N0bmFtZRgCIAEoCRIVCg1odHRwX2hvc3RuYW1lGAMgASgJOqkBukilARqiAQosc3BlYy5pbmdyZXNzLmZyb250ZW5kLmdycGNfaG9zdG5hbWUucmVxdWlyZWQSQ2Zyb250ZW5kLmdycGNfaG9zdG5hbWUgaXMgcmVxdWlyZWQgd2hlbiBmcm9udGVuZCBpbmdyZXNzIGlzIGVuYWJsZWQaLSF0aGlzLmVuYWJsZWQgfHwgc2l6ZSh0aGlzLmdycGNfaG9zdG5hbWUpID4gMCLiAQomS3ViZXJuZXRlc1RlbXBvcmFsV2ViVWlJbmdyZXNzRW5kcG9pbnQSDwoHZW5hYmxlZBgBIAEoCBIQCghob3N0bmFtZRgCIAEoCTqUAbpIkAEajQEKJXNwZWMuaW5ncmVzcy53ZWJfdWkuaG9zdG5hbWUucmVxdWlyZWQSOndlYl91aS5ob3N0bmFtZSBpcyByZXF1aXJlZCB3aGVuIHdlYiB1aSBpbmdyZXNzIGlzIGVuYWJsZWQaKCF0aGlzLmVuYWJsZWQgfHwgc2l6ZSh0aGlzLmhvc3RuYW1lKSA+IDAi6wMKH0t1YmVybmV0ZXNUZW1wb3JhbER5bmFtaWNDb25maWcSMAoYaGlzdG9yeV9zaXplX2xpbWl0X2Vycm9yGAEgASgDQgm6SAYiBCiAgEBIAIgBARIwChloaXN0b3J5X2NvdW50X2xpbWl0X2Vycm9yGAIgASgDQgi6SAUiAyjoB0gBiAEBEi8KF2hpc3Rvcnlfc2l6ZV9saW1pdF93YXJuGAMgASgDQgm6SAYiBCiAgCBIAogBARIvChhoaXN0b3J5X2NvdW50X2xpbWl0X3dhcm4YBCABKANCCLpIBSIDKPQDSAOIAQESLQoVYmxvYl9zaXplX2xpbWl0X2Vycm9yGAUgASgDQgm6SAYiBCiAgEBIBIgBARIsChRibG9iX3NpemVfbGltaXRfd2FybhgGIAEoA0IJukgGIgQogIAQSAWIAQFCGwoZX2hpc3Rvcnlfc2l6ZV9saW1pdF9lcnJvckIcChpfaGlzdG9yeV9jb3VudF9saW1pdF9lcnJvckIaChhfaGlzdG9yeV9zaXplX2xpbWl0X3dhcm5CGwoZX2hpc3RvcnlfY291bnRfbGltaXRfd2FybkIYChZfYmxvYl9zaXplX2xpbWl0X2Vycm9yQhcKFV9ibG9iX3NpemVfbGltaXRfd2FybiKYAQofS3ViZXJuZXRlc1RlbXBvcmFsU2VydmljZUNvbmZpZxIgCghyZXBsaWNhcxgBIAEoBUIJukgGGgQYZCgBSACIAQESRgoJcmVzb3VyY2VzGAIgASgLMjMub3JnLm9wZW5tY2YucHJvdmlkZXIua3ViZXJuZXRlcy5Db250YWluZXJSZXNvdXJjZXNCCwoJX3JlcGxpY2FzIsEDChpLdWJlcm5ldGVzVGVtcG9yYWxTZXJ2aWNlcxJoCghmcm9udGVuZBgBIAEoCzJWLm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc3RlbXBvcmFsLnYxLkt1YmVybmV0ZXNUZW1wb3JhbFNlcnZpY2VDb25maWcSZwoHaGlzdG9yeRgCIAEoCzJWLm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc3RlbXBvcmFsLnYxLkt1YmVybmV0ZXNUZW1wb3JhbFNlcnZpY2VDb25maWcSaAoIbWF0Y2hpbmcYAyABKAsyVi5vcmcub3Blbm1jZi5wcm92aWRlci5rdWJlcm5ldGVzLmt1YmVybmV0ZXN0ZW1wb3JhbC52MS5LdWJlcm5ldGVzVGVtcG9yYWxTZXJ2aWNlQ29uZmlnEmYKBndvcmtlchgEIAEoCzJWLm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc3RlbXBvcmFsLnYxLkt1YmVybmV0ZXNUZW1wb3JhbFNlcnZpY2VDb25maWcqgwEKIUt1YmVybmV0ZXNUZW1wb3JhbERhdGFiYXNlQmFja2VuZBI0CjBrdWJlcm5ldGVzX3RlbXBvcmFsX2RhdGFiYXNlX2JhY2tlbmRfdW5zcGVjaWZpZWQQABINCgljYXNzYW5kcmEQARIOCgpwb3N0Z3Jlc3FsEAISCQoFbXlzcWwQA0KvAwo5Y29tLm9yZy5vcGVubWNmLnByb3ZpZGVyLmt1YmVybmV0ZXMua3ViZXJuZXRlc3RlbXBvcmFsLnYxQglTcGVjUHJvdG9QAVpsZ2l0aHViLmNvbS9wbGFudG9uaHEvb3Blbm1jZi9hcGlzL29yZy9vcGVubWNmL3Byb3ZpZGVyL2t1YmVybmV0ZXMva3ViZXJuZXRlc3RlbXBvcmFsL3YxO2t1YmVybmV0ZXN0ZW1wb3JhbHYxogIFT09QS0uqAjVPcmcuT3Blbm1jZi5Qcm92aWRlci5LdWJlcm5ldGVzLkt1YmVybmV0ZXN0ZW1wb3JhbC5WMcoCNU9yZ1xPcGVubWNmXFByb3ZpZGVyXEt1YmVybmV0ZXNcS3ViZXJuZXRlc3RlbXBvcmFsXFYx4gJBT3JnXE9wZW5tY2ZcUHJvdmlkZXJcS3ViZXJuZXRlc1xLdWJlcm5ldGVzdGVtcG9yYWxcVjFcR1BCTWV0YWRhdGHqAjpPcmc6Ok9wZW5tY2Y6OlByb3ZpZGVyOjpLdWJlcm5ldGVzOjpLdWJlcm5ldGVzdGVtcG9yYWw6OlYxYgZwcm90bzM", [file_buf_validate_validate, file_org_openmcf_provider_kubernetes_kubernetes, file_org_openmcf_provider_kubernetes_kubernetes_secret, file_org_openmcf_provider_kubernetes_target_cluster, file_org_openmcf_shared_foreignkey_v1_foreign_key, file_org_openmcf_shared_options_options]);

/**
 * temporal kubernetes spec defines minimal fields for deploying temporal on kubernetes.
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalSpec
 */
export type KubernetesTemporalSpec = Message<"org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalSpec"> & {
  /**
   * Target Kubernetes Cluster
   *
   * @generated from field: org.openmcf.provider.kubernetes.KubernetesClusterSelector target_cluster = 1;
   */
  targetCluster?: KubernetesClusterSelector;

  /**
   * Kubernetes Namespace
   *
   * @generated from field: org.openmcf.shared.foreignkey.v1.StringValueOrRef namespace = 2;
   */
  namespace?: StringValueOrRef;

  /**
   * flag to indicate if the namespace should be created
   *
   * @generated from field: bool create_namespace = 3;
   */
  createNamespace: boolean;

  /**
   * database configuration
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalDatabaseConfig database = 4;
   */
  database?: KubernetesTemporalDatabaseConfig;

  /**
   * disables temporal web ui
   *
   * @generated from field: bool disable_web_ui = 5;
   */
  disableWebUi: boolean;

  /**
   * enables embedded elasticsearch for temporal
   * this is ignored if external elasticsearch is set
   *
   * @generated from field: bool enable_embedded_elasticsearch = 6;
   */
  enableEmbeddedElasticsearch: boolean;

  /**
   * enables monitoring stack for temporal
   * enabling this will deploy prometheus and grafana
   *
   * @generated from field: bool enable_monitoring_stack = 7;
   */
  enableMonitoringStack: boolean;

  /**
   * number of cassandra nodes to be deployed
   * this is only honored when the backend is cassandra, and no external database is provided.
   *
   * @generated from field: optional int32 cassandra_replicas = 8;
   */
  cassandraReplicas?: number;

  /**
   * The ingress configuration for the temporal deployment.
   * if enabled, the frontend will be exposed using a load-balancer
   * and also if web ui is enabled it will be exposed using the kubernetes ingress controller.
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalIngress ingress = 9;
   */
  ingress?: KubernetesTemporalIngress;

  /**
   * external elasticsearch configuration to be used by temporal for configuring observability.
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalExternalElasticsearch external_elasticsearch = 10;
   */
  externalElasticsearch?: KubernetesTemporalExternalElasticsearch;

  /**
   * version of the Temporal Helm chart to deploy (e.g., "0.62.0")
   * if not specified, the default version configured in the Pulumi module will be used
   *
   * @generated from field: string version = 11;
   */
  version: string;

  /**
   * Dynamic configuration values for Temporal server runtime behavior.
   * These settings control workflow execution limits and can be adjusted without server restart.
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalDynamicConfig dynamic_config = 12;
   */
  dynamicConfig?: KubernetesTemporalDynamicConfig;

  /**
   * *
   * Number of history shards for the Temporal cluster.
   * This is an IMMUTABLE setting that must be decided at cluster creation time.
   * Higher values enable better parallelism and throughput but require more resources.
   * Default: 512 (safe for most production workloads).
   * WARNING: Cannot be changed after initial deployment without data migration.
   *
   * @generated from field: optional int32 num_history_shards = 13;
   */
  numHistoryShards?: number;

  /**
   * Per-service replica and resource configuration for Temporal services.
   * Allows fine-tuning resources for frontend, history, matching, and worker services.
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalServices services = 14;
   */
  services?: KubernetesTemporalServices;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalSpec.
 * Use `create(KubernetesTemporalSpecSchema)` to create a new message.
 */
export const KubernetesTemporalSpecSchema: GenMessage<KubernetesTemporalSpec> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetestemporal_v1_spec, 0);

/**
 * groups database configuration settings.
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalDatabaseConfig
 */
export type KubernetesTemporalDatabaseConfig = Message<"org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalDatabaseConfig"> & {
  /**
   * selected database backend
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalDatabaseBackend backend = 1;
   */
  backend: KubernetesTemporalDatabaseBackend;

  /**
   * external database configuration, if this is not set, in-cluster cassandra would be created
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalExternalDatabase external_database = 2;
   */
  externalDatabase?: KubernetesTemporalExternalDatabase;

  /**
   * primary database or keyspace name
   *
   * @generated from field: optional string database_name = 6;
   */
  databaseName?: string;

  /**
   * visibility database or keyspace name
   *
   * @generated from field: optional string visibility_name = 7;
   */
  visibilityName?: string;

  /**
   * disables automatic schema creation
   *
   * @generated from field: bool disable_auto_schema_setup = 8;
   */
  disableAutoSchemaSetup: boolean;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalDatabaseConfig.
 * Use `create(KubernetesTemporalDatabaseConfigSchema)` to create a new message.
 */
export const KubernetesTemporalDatabaseConfigSchema: GenMessage<KubernetesTemporalDatabaseConfig> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetestemporal_v1_spec, 1);

/**
 * describes an external database that temporal can use
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalExternalDatabase
 */
export type KubernetesTemporalExternalDatabase = Message<"org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalExternalDatabase"> & {
  /**
   * hostname for external database
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * port for external database
   *
   * @generated from field: int32 port = 2;
   */
  port: number;

  /**
   * username for database
   *
   * @generated from field: string username = 3;
   */
  username: string;

  /**
   * *
   * The password for authenticating to the database.
   * Can be provided either as a plain string value or as a reference to an existing Kubernetes Secret.
   *
   * Using a secret reference is recommended for production deployments:
   * ```yaml
   * password:
   *   secretRef:
   *     name: db-credentials
   *     key: password
   * ```
   *
   * For development/testing, a plain string value can be used:
   * ```yaml
   * password:
   *   stringValue: my-password
   * ```
   *
   * @generated from field: org.openmcf.provider.kubernetes.KubernetesSensitiveValue password = 4;
   */
  password?: KubernetesSensitiveValue;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalExternalDatabase.
 * Use `create(KubernetesTemporalExternalDatabaseSchema)` to create a new message.
 */
export const KubernetesTemporalExternalDatabaseSchema: GenMessage<KubernetesTemporalExternalDatabase> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetestemporal_v1_spec, 2);

/**
 * describes an external elasticsearch cluster that temporal can use
 * for advanced visibility instead of deploying an in-cluster es chart.
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalExternalElasticsearch
 */
export type KubernetesTemporalExternalElasticsearch = Message<"org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalExternalElasticsearch"> & {
  /**
   * the host address of the existing elasticsearch cluster
   *
   * @generated from field: string host = 1;
   */
  host: string;

  /**
   * the port for the existing elasticsearch cluster
   *
   * @generated from field: int32 port = 2;
   */
  port: number;

  /**
   * optional username, if the external cluster requires auth
   *
   * @generated from field: string user = 3;
   */
  user: string;

  /**
   * *
   * Optional password for authenticating to the external Elasticsearch cluster.
   * Can be provided either as a plain string value or as a reference to an existing Kubernetes Secret.
   *
   * Using a secret reference is recommended for production deployments:
   * ```yaml
   * password:
   *   secretRef:
   *     name: es-credentials
   *     key: password
   * ```
   *
   * For development/testing, a plain string value can be used:
   * ```yaml
   * password:
   *   stringValue: my-password
   * ```
   *
   * @generated from field: org.openmcf.provider.kubernetes.KubernetesSensitiveValue password = 4;
   */
  password?: KubernetesSensitiveValue;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalExternalElasticsearch.
 * Use `create(KubernetesTemporalExternalElasticsearchSchema)` to create a new message.
 */
export const KubernetesTemporalExternalElasticsearchSchema: GenMessage<KubernetesTemporalExternalElasticsearch> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetestemporal_v1_spec, 3);

/**
 * ingress configuration for temporal deployment with separate frontend and web ui endpoints
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalIngress
 */
export type KubernetesTemporalIngress = Message<"org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalIngress"> & {
  /**
   * frontend (gRPC + HTTP) ingress configuration
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalFrontendIngressEndpoint frontend = 1;
   */
  frontend?: KubernetesTemporalFrontendIngressEndpoint;

  /**
   * web ui ingress configuration
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalWebUiIngressEndpoint web_ui = 2;
   */
  webUi?: KubernetesTemporalWebUiIngressEndpoint;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalIngress.
 * Use `create(KubernetesTemporalIngressSchema)` to create a new message.
 */
export const KubernetesTemporalIngressSchema: GenMessage<KubernetesTemporalIngress> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetestemporal_v1_spec, 4);

/**
 * frontend ingress endpoint configuration supporting both gRPC and HTTP protocols
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalFrontendIngressEndpoint
 */
export type KubernetesTemporalFrontendIngressEndpoint = Message<"org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalFrontendIngressEndpoint"> & {
  /**
   * flag to enable or disable frontend ingress
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * the full hostname for gRPC access via LoadBalancer (e.g., "temporal-frontend-grpc.example.com")
   * required when enabled is true
   *
   * @generated from field: string grpc_hostname = 2;
   */
  grpcHostname: string;

  /**
   * the full hostname for HTTP access via Gateway API (e.g., "temporal-frontend-http.example.com")
   * optional - only creates Gateway/HTTPRoute resources if provided
   *
   * @generated from field: string http_hostname = 3;
   */
  httpHostname: string;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalFrontendIngressEndpoint.
 * Use `create(KubernetesTemporalFrontendIngressEndpointSchema)` to create a new message.
 */
export const KubernetesTemporalFrontendIngressEndpointSchema: GenMessage<KubernetesTemporalFrontendIngressEndpoint> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetestemporal_v1_spec, 5);

/**
 * web ui ingress endpoint configuration for HTTP-only access
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalWebUiIngressEndpoint
 */
export type KubernetesTemporalWebUiIngressEndpoint = Message<"org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalWebUiIngressEndpoint"> & {
  /**
   * flag to enable or disable web ui ingress
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * the full hostname for HTTP access via Gateway API (e.g., "temporal-ui.example.com")
   * required when enabled is true
   *
   * @generated from field: string hostname = 2;
   */
  hostname: string;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalWebUiIngressEndpoint.
 * Use `create(KubernetesTemporalWebUiIngressEndpointSchema)` to create a new message.
 */
export const KubernetesTemporalWebUiIngressEndpointSchema: GenMessage<KubernetesTemporalWebUiIngressEndpoint> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetestemporal_v1_spec, 6);

/**
 * *
 * Dynamic configuration values for Temporal server runtime behavior.
 * These settings control workflow execution limits without requiring server restart.
 * When not specified, Temporal uses its default values.
 *
 * Two types of limits:
 * - **History limits**: Control total workflow history size and event count
 * - **Blob limits**: Control individual payload sizes (markers, signals, activity I/O)
 *
 * Example:
 * ```yaml
 * dynamic_config:
 *   history_size_limit_error: 104857600  # 100 MB total history
 *   history_count_limit_error: 102400    # 100K events
 *   blob_size_limit_error: 10485760      # 10 MB per payload (for large IaC diffs)
 *   blob_size_limit_warn: 5242880        # 5 MB warning threshold
 * ```
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalDynamicConfig
 */
export type KubernetesTemporalDynamicConfig = Message<"org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalDynamicConfig"> & {
  /**
   * *
   * Maximum size in bytes for workflow execution history.
   * When a workflow exceeds this limit, Temporal terminates it with reason "Workflow history size exceeds limit."
   * Default: 52428800 (50 MB). Increase for workflows with large payloads.
   *
   * @generated from field: optional int64 history_size_limit_error = 1;
   */
  historySizeLimitError?: bigint;

  /**
   * *
   * Maximum number of events in workflow execution history.
   * When a workflow exceeds this limit, Temporal terminates it with reason "Workflow history size exceeds limit."
   * Default: 51200 events. Increase for workflows with many activities/signals.
   * Consider using ContinueAsNew pattern as an alternative.
   *
   * @generated from field: optional int64 history_count_limit_error = 2;
   */
  historyCountLimitError?: bigint;

  /**
   * *
   * Warning threshold for history size in bytes.
   * Temporal logs warnings when workflows approach this limit.
   * Default: 10485760 (10 MB, ~20% of error limit).
   *
   * @generated from field: optional int64 history_size_limit_warn = 3;
   */
  historySizeLimitWarn?: bigint;

  /**
   * *
   * Warning threshold for history event count.
   * Temporal logs warnings when workflows approach this limit.
   * Default: 10240 (~20% of error limit).
   *
   * @generated from field: optional int64 history_count_limit_warn = 4;
   */
  historyCountLimitWarn?: bigint;

  /**
   * *
   * Maximum size in bytes for a single blob/payload (marker details, signal data, activity I/O).
   * When a payload exceeds this limit, Temporal rejects it with "exceeds size limit" error.
   * This is different from history_size_limit which controls total workflow history size.
   * Default: 2097152 (2 MB). Increase for workflows that send large payloads like IaC diffs.
   *
   * Example: Set to 10485760 (10 MB) to support large Pulumi diffs.
   *
   * @generated from field: optional int64 blob_size_limit_error = 5;
   */
  blobSizeLimitError?: bigint;

  /**
   * *
   * Warning threshold for blob/payload size in bytes.
   * Temporal logs warnings when payloads approach this limit.
   * Default: 524288 (512 KB, ~25% of error limit).
   *
   * @generated from field: optional int64 blob_size_limit_warn = 6;
   */
  blobSizeLimitWarn?: bigint;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalDynamicConfig.
 * Use `create(KubernetesTemporalDynamicConfigSchema)` to create a new message.
 */
export const KubernetesTemporalDynamicConfigSchema: GenMessage<KubernetesTemporalDynamicConfig> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetestemporal_v1_spec, 7);

/**
 * *
 * Per-service replica and resource configuration for a Temporal service.
 * Allows configuring replicas and CPU/memory resources independently for each service.
 *
 * Example:
 * ```yaml
 * replicas: 3
 * resources:
 *   limits:
 *     cpu: "2000m"
 *     memory: "4Gi"
 *   requests:
 *     cpu: "500m"
 *     memory: "1Gi"
 * ```
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalServiceConfig
 */
export type KubernetesTemporalServiceConfig = Message<"org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalServiceConfig"> & {
  /**
   * *
   * Number of replicas for this service.
   * Higher replica counts provide better availability and throughput.
   * Default: 1 for development, recommend 3+ for production.
   *
   * @generated from field: optional int32 replicas = 1;
   */
  replicas?: number;

  /**
   * *
   * Container resources (CPU and memory) for this service.
   * Resource requirements vary by service type:
   * - history: Most resource-intensive, handles workflow state
   * - matching: Task dispatch, moderate resources
   * - frontend: API gateway, moderate resources
   * - worker: Internal workflows, light resources
   *
   * @generated from field: org.openmcf.provider.kubernetes.ContainerResources resources = 2;
   */
  resources?: ContainerResources;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalServiceConfig.
 * Use `create(KubernetesTemporalServiceConfigSchema)` to create a new message.
 */
export const KubernetesTemporalServiceConfigSchema: GenMessage<KubernetesTemporalServiceConfig> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetestemporal_v1_spec, 8);

/**
 * *
 * Service-level configuration for all Temporal services.
 * Allows fine-tuning replica counts and resources for each Temporal service independently.
 *
 * Temporal consists of four core services:
 * - **frontend**: API gateway for client requests (gRPC/HTTP)
 * - **history**: Manages workflow state and execution (most resource-intensive)
 * - **matching**: Task queue management and worker dispatch
 * - **worker**: Runs internal Temporal system workflows
 *
 * Example:
 * ```yaml
 * services:
 *   frontend:
 *     replicas: 2
 *     resources:
 *       requests:
 *         cpu: "200m"
 *         memory: "512Mi"
 *   history:
 *     replicas: 3
 *     resources:
 *       requests:
 *         cpu: "500m"
 *         memory: "1Gi"
 *       limits:
 *         cpu: "2000m"
 *         memory: "4Gi"
 * ```
 *
 * @generated from message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalServices
 */
export type KubernetesTemporalServices = Message<"org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalServices"> & {
  /**
   * Frontend service configuration (API gateway for gRPC/HTTP requests)
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalServiceConfig frontend = 1;
   */
  frontend?: KubernetesTemporalServiceConfig;

  /**
   * History service configuration (manages workflow state, most resource-intensive)
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalServiceConfig history = 2;
   */
  history?: KubernetesTemporalServiceConfig;

  /**
   * Matching service configuration (task queue management and dispatch)
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalServiceConfig matching = 3;
   */
  matching?: KubernetesTemporalServiceConfig;

  /**
   * Worker service configuration (internal Temporal system workflows)
   *
   * @generated from field: org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalServiceConfig worker = 4;
   */
  worker?: KubernetesTemporalServiceConfig;
};

/**
 * Describes the message org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalServices.
 * Use `create(KubernetesTemporalServicesSchema)` to create a new message.
 */
export const KubernetesTemporalServicesSchema: GenMessage<KubernetesTemporalServices> = /*@__PURE__*/
  messageDesc(file_org_openmcf_provider_kubernetes_kubernetestemporal_v1_spec, 9);

/**
 * temporal kubernetes database backend enumerates the supported databases.
 *
 * @generated from enum org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalDatabaseBackend
 */
export enum KubernetesTemporalDatabaseBackend {
  /**
   * unspecified should not be used
   *
   * @generated from enum value: kubernetes_temporal_database_backend_unspecified = 0;
   */
  kubernetes_temporal_database_backend_unspecified = 0,

  /**
   * uses cassandra
   *
   * @generated from enum value: cassandra = 1;
   */
  cassandra = 1,

  /**
   * uses postgresql
   *
   * @generated from enum value: postgresql = 2;
   */
  postgresql = 2,

  /**
   * uses mysql
   *
   * @generated from enum value: mysql = 3;
   */
  mysql = 3,
}

/**
 * Describes the enum org.openmcf.provider.kubernetes.kubernetestemporal.v1.KubernetesTemporalDatabaseBackend.
 */
export const KubernetesTemporalDatabaseBackendSchema: GenEnum<KubernetesTemporalDatabaseBackend> = /*@__PURE__*/
  enumDesc(file_org_openmcf_provider_kubernetes_kubernetestemporal_v1_spec, 0);

